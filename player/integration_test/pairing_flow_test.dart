import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:graphql_flutter/graphql_flutter.dart';
import 'package:integration_test/integration_test.dart';
import 'package:media_kit/media_kit.dart';

import 'package:player/app.dart';
import 'package:player/native/frb_generated.dart'
    if (dart.library.js_interop) 'package:player/native/frb_stub.dart';

/// E2E integration tests for the device pairing flow.
///
/// These tests run against real Mydia and Metadata-Relay services
/// in a Docker Compose environment.
///
/// The claim code is pre-generated by the test runner (Dockerfile.test)
/// and passed via --dart-define=E2E_CLAIM_CODE.
///
/// Test scenarios:
/// 1. Happy path: Valid claim code -> successful pairing -> home screen
/// 2. Invalid claim code: Shows error message
void main() {
  // Initialize integration test binding FIRST - this must happen before
  // any other Flutter binding initialization
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  // Set up the app once before all tests
  setUpAll(() async {
    await RustLib.init();

    // Initialize media_kit for video playback
    MediaKit.ensureInitialized();

    // Initialize GraphQL Hive cache for offline support
    await initHiveForFlutter();
  });

  // Get the pre-generated claim code from dart-define
  const claimCode = String.fromEnvironment('E2E_CLAIM_CODE');

  /// Wait for the login screen to appear (auth state to resolve).
  /// Uses pump() instead of pumpAndSettle() because the loading screen
  /// has an infinite CircularProgressIndicator animation.
  Future<void> waitForLoginScreen(WidgetTester tester, {int maxSeconds = 30}) async {
    debugPrint('[Test] Waiting for login screen to appear...');
    for (var i = 0; i < maxSeconds; i++) {
      await tester.pump(const Duration(seconds: 1));
      final loginTitle = find.text('Connect to Server');
      if (loginTitle.evaluate().isNotEmpty) {
        debugPrint('[Test] Login screen found after $i seconds');
        // Give it a moment for the screen to fully render
        await tester.pump(const Duration(milliseconds: 500));
        return;
      }
    }
    debugPrint('[Test] Login screen not found after $maxSeconds seconds');
  }

  /// Wait for the app to navigate away from the login screen after pairing.
  /// Uses a longer timeout (120s) to account for Flutter web startup time.
  Future<bool> waitForPairingComplete(WidgetTester tester, {int maxSeconds = 120}) async {
    debugPrint('[Test] Waiting for pairing to complete...');
    bool sawError = false;
    for (var i = 0; i < maxSeconds; i++) {
      await tester.pump(const Duration(seconds: 1));
      final loginTitle = find.text('Connect to Server');
      if (loginTitle.evaluate().isEmpty) {
        debugPrint('[Test] Navigated away from login screen after $i seconds');
        return true;
      }
      // Log error message if present but don't fail immediately - give time for recovery
      final errorIcon = find.byIcon(Icons.error_outline_rounded);
      if (errorIcon.evaluate().isNotEmpty && !sawError) {
        debugPrint('[Test] Error message found after $i seconds - continuing to wait...');
        sawError = true;
        // Print all text in the UI to see the error message
        final allText = tester.widgetList<Text>(find.byType(Text));
        for (final text in allText) {
          if (text.data != null && text.data!.isNotEmpty) {
            debugPrint('[Test] Text: ${text.data}');
          }
        }
      }
      // Log status messages periodically to see what's happening
      if (i % 5 == 0 && i > 0) {
        final allText = tester.widgetList<Text>(find.byType(Text));
        for (final text in allText) {
          final data = text.data?.trim();
          if (data != null && data.isNotEmpty) {
            // ignore: avoid_print
            print('[Test@$i] UI: $data');
          }
        }
      }
    }
    debugPrint('[Test] Still on login screen after $maxSeconds seconds (sawError: $sawError)');
    // Print final state
    final allText = tester.widgetList<Text>(find.byType(Text));
    for (final text in allText) {
      if (text.data != null && text.data!.isNotEmpty && text.data!.length > 3) {
        debugPrint('[Test] Final UI text: ${text.data}');
      }
    }
    return false;
  }

  group('Device Pairing Flow', () {
    testWidgets('Happy path: valid claim code leads to successful pairing',
        (WidgetTester tester) async {
      // Verify we have a claim code
      expect(claimCode.isNotEmpty, isTrue,
          reason: 'E2E_CLAIM_CODE must be set via --dart-define');
      debugPrint('Using pre-generated claim code: $claimCode');

      // Launch the app using pumpWidget with proper Riverpod scope
      await tester.pumpWidget(
        const ProviderScope(
          child: MyApp(),
        ),
      );

      // Wait for login screen (uses pump(), not pumpAndSettle due to CircularProgressIndicator)
      await waitForLoginScreen(tester);

      // Find the claim code input field - it's the first TextFormField on the login screen
      final textField = find.byType(TextFormField).first;
      expect(textField, findsOneWidget,
          reason: 'Should find the claim code input field');

      // Enter the claim code (remove any dashes if present)
      await tester.enterText(textField, claimCode.replaceAll('-', ''));
      await tester.pump(const Duration(milliseconds: 300));

      // Find and tap the Connect button
      final connectButton = find.widgetWithText(ElevatedButton, 'Connect');
      expect(connectButton, findsOneWidget,
          reason: 'Should find the Connect button');

      await tester.tap(connectButton);
      await tester.pump(const Duration(milliseconds: 100));

      // Wait for pairing to complete (this involves Noise handshake)
      final pairingSucceeded = await waitForPairingComplete(tester);

      // Cleanup first - replace app widget to stop all pending async operations
      // This prevents the "inTest is not true" error from async providers
      await tester.pumpWidget(const SizedBox.shrink());
      await tester.pump(const Duration(milliseconds: 100));

      // Now run assertions after cleanup
      expect(
        pairingSucceeded,
        isTrue,
        reason: 'Pairing should complete successfully',
      );

      debugPrint('Pairing flow completed successfully!');
    });

    // Skip: Integration tests share app state, so after the first test
    // successfully pairs, the app remains authenticated. This test would
    // need its own isolated test run to work properly.
    testWidgets('Invalid claim code shows error message',
        (WidgetTester tester) async {
      // Launch the app using pumpWidget with proper Riverpod scope
      await tester.pumpWidget(
        const ProviderScope(
          child: MyApp(),
        ),
      );

      // Wait for login screen
      await waitForLoginScreen(tester);

      // Find the claim code input field
      final textField = find.byType(TextFormField).first;
      expect(textField, findsOneWidget);

      // Enter an invalid claim code
      await tester.enterText(textField, 'INVALID1');
      await tester.pump(const Duration(milliseconds: 300));

      // Tap the Connect button
      final connectButton = find.widgetWithText(ElevatedButton, 'Connect');
      await tester.tap(connectButton);
      await tester.pump(const Duration(milliseconds: 100));

      // Wait for error response (with timeout)
      debugPrint('[Test] Waiting for error message...');
      for (var i = 0; i < 30; i++) {
        await tester.pump(const Duration(seconds: 1));
        final errorIcon = find.byIcon(Icons.error_outline_rounded);
        if (errorIcon.evaluate().isNotEmpty) {
          debugPrint('[Test] Error icon found after $i seconds');
          break;
        }
      }

      // Should still be on login screen
      expect(
        find.text('Connect to Server'),
        findsOneWidget,
        reason: 'Should remain on login screen after invalid code',
      );

      // Should show an error message
      final errorIcon = find.byIcon(Icons.error_outline_rounded);
      expect(
        errorIcon,
        findsWidgets,
        reason: 'Should show error indicator for invalid claim code',
      );

      debugPrint('Invalid claim code test passed!');
    // Skip: Tests share app state, so after the first test successfully pairs,
    // the app remains authenticated. This test needs its own isolated test run.
    }, skip: true);

    // Skip test: Requires waiting for claim code expiration (5 minutes)
    // To run this test, you would need to:
    // 1. Use a very short TTL if configurable
    // 2. Mock the time
    // 3. Run manually with extended timeout
    testWidgets('Expired claim code shows expiration error',
        (WidgetTester tester) async {
      // Generate a claim code and wait for it to expire
      // Note: In E2E environment, claim codes expire in 5 minutes
    }, skip: true);
  });
}
