import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';

import 'package:player/main.dart' as app;

/// E2E integration tests for the device pairing flow.
///
/// These tests run against real Mydia and Metadata-Relay services
/// in a Docker Compose environment.
///
/// The claim code is pre-generated by the test runner (Dockerfile.test)
/// and passed via --dart-define=E2E_CLAIM_CODE.
///
/// Test scenarios:
/// 1. Happy path: Valid claim code -> successful pairing -> home screen
/// 2. Invalid claim code: Shows error message
void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  // Get the pre-generated claim code from dart-define
  const claimCode = String.fromEnvironment('E2E_CLAIM_CODE');

  group('Device Pairing Flow', () {
    testWidgets('Happy path: valid claim code leads to successful pairing',
        (WidgetTester tester) async {
      // Verify we have a claim code
      expect(claimCode.isNotEmpty, isTrue,
          reason: 'E2E_CLAIM_CODE must be set via --dart-define');
      debugPrint('Using pre-generated claim code: $claimCode');

      // Launch the app
      app.main();
      await tester.pumpAndSettle();

      // Wait for login screen to appear
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Find the claim code input field - it's the first TextFormField on the login screen
      // The claim code field has centered text with letter-spacing styling
      final textField = find.byType(TextFormField).first;

      expect(textField, findsOneWidget,
          reason: 'Should find the claim code input field');

      // Enter the claim code (remove any dashes if present)
      await tester.enterText(textField, claimCode.replaceAll('-', ''));
      await tester.pumpAndSettle();

      // Find and tap the Connect button
      final connectButton = find.widgetWithText(ElevatedButton, 'Connect');
      expect(connectButton, findsOneWidget,
          reason: 'Should find the Connect button');

      await tester.tap(connectButton);

      // Wait for pairing to complete (this involves Noise handshake)
      // Give it up to 30 seconds for the full flow
      await tester.pumpAndSettle(const Duration(seconds: 30));

      // After successful pairing, we should be on the home screen
      // The app navigates to '/' on success
      // Look for common home screen elements

      // Option 1: Check we're no longer on login screen
      final loginTitle = find.text('Connect to Server');

      // If still on login screen, check for success or error
      if (loginTitle.evaluate().isNotEmpty) {
        // Check if there's an error message
        final errorContainer = find.byWidgetPredicate(
          (widget) =>
              widget is Container &&
              widget.decoration is BoxDecoration &&
              (widget.decoration as BoxDecoration).color?.value ==
                  Colors.red.withOpacity(0.1).value,
        );

        if (errorContainer.evaluate().isNotEmpty) {
          fail('Pairing failed with an error. Check logs for details.');
        }

        // Check for loading indicator
        final loadingIndicator = find.byType(CircularProgressIndicator);
        if (loadingIndicator.evaluate().isNotEmpty) {
          // Still loading, wait more
          await tester.pumpAndSettle(const Duration(seconds: 30));
        }
      }

      // Verify we're no longer on login screen (pairing succeeded)
      expect(
        find.text('Connect to Server'),
        findsNothing,
        reason: 'Should have navigated away from login screen after pairing',
      );

      debugPrint('Pairing flow completed successfully!');
    });

    testWidgets('Invalid claim code shows error message',
        (WidgetTester tester) async {
      // Launch the app
      app.main();
      await tester.pumpAndSettle();

      // Wait for login screen to appear
      await tester.pumpAndSettle(const Duration(seconds: 2));

      // Find the claim code input field
      final textField = find.byType(TextFormField).first;
      expect(textField, findsOneWidget);

      // Enter an invalid claim code
      await tester.enterText(textField, 'INVALID1');
      await tester.pumpAndSettle();

      // Tap the Connect button
      final connectButton = find.widgetWithText(ElevatedButton, 'Connect');
      await tester.tap(connectButton);

      // Wait for error response
      await tester.pumpAndSettle(const Duration(seconds: 10));

      // Should still be on login screen
      expect(
        find.text('Connect to Server'),
        findsOneWidget,
        reason: 'Should remain on login screen after invalid code',
      );

      // Should show an error message
      // The error could be in various forms, let's check for error styling
      final errorIcon = find.byIcon(Icons.error_outline_rounded);
      expect(
        errorIcon,
        findsWidgets,
        reason: 'Should show error indicator for invalid claim code',
      );

      debugPrint('Invalid claim code test passed!');
    });

    // Skip test: Requires waiting for claim code expiration (5 minutes)
    // To run this test, you would need to:
    // 1. Use a very short TTL if configurable
    // 2. Mock the time
    // 3. Run manually with extended timeout
    testWidgets('Expired claim code shows expiration error',
        (WidgetTester tester) async {
      // Generate a claim code and wait for it to expire
      // Note: In E2E environment, claim codes expire in 5 minutes
    }, skip: true);
  });
}
