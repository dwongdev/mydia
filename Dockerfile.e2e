# syntax=docker/dockerfile:1.4
# ============================================
# E2E Test Build - Mydia
# ============================================
# This Dockerfile builds Mydia for E2E integration testing.
# It's based on the production Dockerfile but includes:
# - E2E seed script for automatic setup
# - Test user creation on startup
# - Remote access auto-enable
#
# Build with: DOCKER_BUILDKIT=1 docker build -f Dockerfile.e2e .

# ============================================
# Build Stage
# ============================================
FROM elixir:1.18-alpine AS builder

# Database type: sqlite (for E2E we always use sqlite)
ARG DATABASE_TYPE=sqlite

# Install build dependencies
RUN apk add --no-cache \
    build-base \
    git \
    nodejs \
    npm \
    sqlite-dev \
    rust \
    cargo \
    curl

# Set build environment
ENV MIX_ENV=prod
ENV DATABASE_TYPE=${DATABASE_TYPE}
ENV HEX_HOME=/root/.hex
ENV MIX_HOME=/root/.mix
# Increase hex timeout for slow networks/CI (5 minutes)
ENV HEX_HTTP_TIMEOUT=300000

# Install Hex and Rebar with cache
RUN --mount=type=cache,target=/root/.hex \
    --mount=type=cache,target=/root/.mix \
    mix local.hex --force && \
    mix local.rebar --force

# Create app directory
WORKDIR /app

# Copy dependency manifests (for better layer caching)
COPY mix.exs mix.lock ./

# Install dependencies with cache (with retry for transient network failures)
RUN --mount=type=cache,target=/root/.hex \
    --mount=type=cache,target=/root/.mix \
    --mount=type=cache,target=/app/deps \
    for i in 1 2 3; do \
      mix deps.get --only prod && break || \
      (echo "Attempt $i failed, retrying in 10s..." && sleep 10); \
    done && \
    cp -r deps deps_copy

# Restore deps from cache copy
RUN rm -rf deps && mv deps_copy deps

# Apply patches to dependencies
COPY patches/ueberauth_oidcc_request.ex ./deps/ueberauth_oidcc/lib/ueberauth_oidcc/request.ex

# Compile dependencies with cache
RUN --mount=type=cache,target=/root/.hex \
    --mount=type=cache,target=/root/.mix \
    --mount=type=cache,target=/app/_build,sharing=locked \
    mix deps.compile && \
    cp -r _build _build_copy

# Restore _build from cache copy
RUN rm -rf _build && mv _build_copy _build

# Copy application source (excluding player - we don't need Flutter for E2E server)
COPY config ./config
COPY priv ./priv
COPY lib ./lib
COPY assets ./assets
COPY native ./native

# Compile application
RUN --mount=type=cache,target=/root/.hex \
    --mount=type=cache,target=/root/.mix \
    mix compile

# Build Phoenix assets with npm cache
RUN --mount=type=cache,target=/root/.hex \
    --mount=type=cache,target=/root/.mix \
    --mount=type=cache,target=/root/.npm \
    cd assets && \
    npm ci --prefix . --progress=false --no-audit --loglevel=error && \
    cd .. && \
    mix assets.deploy

# Build release
RUN --mount=type=cache,target=/root/.hex \
    --mount=type=cache,target=/root/.mix \
    mix release

# ============================================
# Runtime Stage
# ============================================
FROM erlang:27-alpine

ARG DATABASE_TYPE=sqlite

LABEL org.opencontainers.image.title="Mydia E2E Test" \
      org.opencontainers.image.description="Mydia build for E2E integration testing"

# Install runtime dependencies
RUN apk add --no-cache \
    sqlite \
    curl \
    ca-certificates \
    ffmpeg \
    fdk-aac \
    su-exec \
    tzdata \
    shadow \
    openssl

# Create app user
RUN addgroup -g 1000 mydia && \
    adduser -D -u 1000 -G mydia mydia

# Create necessary directories
RUN mkdir -p /app /config /data /media && \
    chown -R mydia:mydia /app /config /data /media

WORKDIR /app

# Copy release from builder
COPY --from=builder --chown=mydia:mydia /app/_build/prod/rel/mydia ./

# Copy E2E entrypoint script
COPY <<'EOF' /docker-entrypoint.sh
#!/bin/sh
set -e

PUID=${PUID:-1000}
PGID=${PGID:-1000}

echo "Starting Mydia E2E Server..."
echo "E2E_MODE: ${E2E_MODE:-false}"

# Ensure directories exist
mkdir -p /config /data /media
chown -R "$PUID:$PGID" /config /data /app

# Run migrations
echo "Running database migrations..."
su-exec mydia /app/bin/mydia eval "Mydia.Release.migrate()"

# Start the application
echo "Starting Mydia server..."
su-exec mydia /app/bin/mydia start &
APP_PID=$!

cleanup() {
    if kill -0 "$APP_PID" 2>/dev/null; then
        kill -TERM "$APP_PID" 2>/dev/null || true
        wait "$APP_PID" || true
    fi
}
trap cleanup INT TERM

echo "Waiting for Mydia to become healthy..."
max_attempts=30
attempt=0
while [ $attempt -lt $max_attempts ]; do
    if curl -sf "http://localhost:4000/health" > /dev/null 2>&1; then
        echo "Mydia is healthy."
        break
    fi
    attempt=$((attempt + 1))
    sleep 2
done

if [ $attempt -eq $max_attempts ]; then
    echo "Mydia failed to become healthy in time."
    cleanup
    exit 1
fi

# E2E setup: create admin user and enable remote access (app must be running for endpoint config)
if [ "$E2E_MODE" = "true" ]; then
    echo "E2E Mode enabled - setting up test environment..."

    # Create admin user if configured
    if [ -n "$E2E_ADMIN_EMAIL" ] && [ -n "$E2E_ADMIN_PASSWORD" ]; then
        echo "Creating admin user: $E2E_ADMIN_EMAIL"
        su-exec mydia /app/bin/mydia rpc "
            case Mydia.Accounts.get_user_by_email(\"$E2E_ADMIN_EMAIL\") do
                nil ->
                    case Mydia.Accounts.create_user(%{
                        username: \"e2e_admin\",
                        email: \"$E2E_ADMIN_EMAIL\",
                        password: \"$E2E_ADMIN_PASSWORD\",
                        role: \"admin\"
                    }) do
                        {:ok, user} -> IO.puts(\"Admin user created: #{user.email}\")
                        {:error, changeset} -> IO.puts(\"Failed to create user: #{inspect(changeset.errors)}\")
                    end
                user ->
                    IO.puts(\"Admin user already exists: #{user.email}\")
            end
        " 2>&1 || echo "Warning: Could not create admin user"
    fi

    echo "Initializing remote access..."
    su-exec mydia /app/bin/mydia rpc "
        case Mydia.RemoteAccess.get_config() do
            nil ->
                case Mydia.RemoteAccess.initialize_keypair() do
                    {:ok, _config} ->
                        case Mydia.RemoteAccess.toggle_remote_access(true) do
                            {:ok, _} -> IO.puts(\"Remote access initialized and enabled\")
                            {:error, reason} -> IO.puts(\"Failed to enable remote access: #{inspect(reason)}\")
                        end
                    {:error, reason} ->
                        IO.puts(\"Failed to initialize keypair: #{inspect(reason)}\")
                end
            config ->
                if config.enabled do
                    IO.puts(\"Remote access already enabled\")
                else
                    case Mydia.RemoteAccess.toggle_remote_access(true) do
                        {:ok, _} -> IO.puts(\"Remote access enabled\")
                        {:error, reason} -> IO.puts(\"Failed to enable remote access: #{inspect(reason)}\")
                    end
                end
        end
    " 2>&1 || echo "Warning: Could not initialize remote access"

    # Seed test media for streaming tests
    echo "Seeding test media..."
    mkdir -p /media/movies
    ffmpeg -y -f lavfi -i testsrc2=duration=5:size=1280x720:rate=24 \
           -f lavfi -i sine=frequency=440:duration=5 \
           -c:v libx264 -preset ultrafast -crf 28 -pix_fmt yuv420p \
           -g 24 -keyint_min 24 \
           -c:a aac -b:a 128k \
           -movflags +faststart \
           /media/movies/e2e-test-video.mp4 2>&1 || echo "Warning: Could not generate test video"

    if [ -f /media/movies/e2e-test-video.mp4 ]; then
        chown mydia:mydia /media/movies/e2e-test-video.mp4
        echo "Test video generated, creating library entries..."
        su-exec mydia /app/bin/mydia rpc "
            alias Mydia.{Settings, Media, Library, Repo}
            alias Mydia.Settings.LibraryPath

            file_size = File.stat!(\"/media/movies/e2e-test-video.mp4\").size

            # Find or create library path (may already exist from auto-scan)
            lib_path = case Repo.get_by(LibraryPath, path: \"/media/movies\") do
              nil ->
                case Settings.create_library_path(%{path: \"/media/movies\", type: :movies}) do
                  {:ok, lp} -> lp
                  {:error, reason} ->
                    IO.puts(\"Failed to create library path: #{inspect(reason)}\")
                    nil
                end
              existing -> existing
            end

            if lib_path do
              with {:ok, movie} <- Media.create_media_item(%{type: \"movie\", title: \"E2E Test Movie\", year: 2025}, skip_episode_refresh: true),
                   {:ok, _file} <- Library.create_media_file(%{
                     media_item_id: movie.id,
                     library_path_id: lib_path.id,
                     relative_path: \"e2e-test-video.mp4\",
                     size: file_size,
                     resolution: \"720p\",
                     codec: \"h264\",
                     audio_codec: \"aac\",
                     metadata: %{\"duration\" => 5.0}
                   }) do
                IO.puts(\"Test media seeded: E2E Test Movie (#{file_size} bytes)\")
              else
                {:error, reason} ->
                  IO.puts(\"Failed to seed test media: #{inspect(reason)}\")
              end
            end
        " 2>&1 || echo "Warning: Could not seed test media"
    else
        echo "Warning: Test video file was not generated"
    fi

    echo "E2E setup complete!"
fi

wait "$APP_PID"
EOF

RUN chmod +x /docker-entrypoint.sh

# Set environment variables
ENV HOME=/app \
    MIX_ENV=prod \
    PHX_SERVER=true \
    DATABASE_TYPE=${DATABASE_TYPE} \
    DATABASE_PATH=/config/mydia.db \
    P2P_KEYPAIR_PATH=/config/p2p_keypair.bin \
    PORT=4000 \
    PUID=1000 \
    PGID=1000 \
    TZ=UTC

EXPOSE 4000 4443

VOLUME ["/config", "/data", "/media"]

HEALTHCHECK --interval=5s --timeout=3s --start-period=30s --retries=10 \
    CMD curl -f http://localhost:4000/health || exit 1

ENTRYPOINT ["/docker-entrypoint.sh"]
