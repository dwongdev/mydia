#!/usr/bin/env bash

# Dev command wrapper for docker compose management
# Provides convenient shortcuts for common development operations

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
COMPOSE_FILE="compose.yml"
SERVICE_NAME="app"

# Export current user's UID/GID for Docker to use
# This ensures files created in containers are owned by the host user
export LOCAL_UID=$(id -u)
export LOCAL_GID=$(id -g)

# Check if docker is available
if ! command -v docker &> /dev/null; then
    echo -e "${RED}Error: docker is not installed or not in PATH${NC}"
    echo "Please install Docker: https://docs.docker.com/get-docker/"
    exit 1
fi

# Check if docker compose is available
if ! docker compose version &> /dev/null; then
    echo -e "${RED}Error: docker compose is not available${NC}"
    echo "Please install Docker Compose: https://docs.docker.com/compose/install/"
    exit 1
fi

# Check if compose file exists
if [ ! -f "$COMPOSE_FILE" ]; then
    echo -e "${RED}Error: $COMPOSE_FILE not found${NC}"
    echo "Please run this script from the project root directory"
    exit 1
fi

# Show help if no arguments provided
if [ $# -eq 0 ]; then
    cat <<EOF
${GREEN}Mydia Development Helper${NC}

Usage: ./dev <command> [arguments...]

${YELLOW}Common Commands:${NC}
  up [-d]              Start services (add -d for detached mode)
  down                 Stop and remove containers
  restart              Restart services
  logs [-f] [service]  View logs (add -f to follow)
  ps                   List running containers
  stop                 Stop services
  start                Start services

${YELLOW}Container Commands:${NC}
  shell                Open an interactive shell in the app container
  mix <args>           Run mix commands inside the container
  iex                  Start IEx inside the container
  bash                 Open bash shell in the app container

${YELLOW}Development Commands:${NC}
  test [args]          Run tests (mix test)
  feature-test [args]  Run Wallaby browser tests
  format               Format code (mix format)
  deps.get             Install dependencies
  ecto.migrate         Run database migrations
  ecto.reset           Reset database
  phx.server           Start Phoenix server
  mix precommit        Run precommit checks in isolated container

${YELLOW}User Management:${NC}
  user list [--role=R] List all users (optionally filter by role)
  user add <email> <username> [opts]
                       Add a new user (--password, --role, --display-name)
  user delete <id>     Delete a user by email or username
  user reset-password <id> [--password=P]
                       Reset a user's password

${YELLOW}Player (Flutter in App Container):${NC}
  flutter <args>       Run any flutter command in app container
  player setup         Install deps and run code generation
  player build         Build web assets (FlutterWatcher handles deployment)
  player shell         Open shell in player directory
  player logs          Follow build_runner logs
  player restart       Restart app container (includes build_runner)
  player e2e           Run player E2E integration tests
  player e2e-build     Pre-build E2E images (faster subsequent runs)

${YELLOW}Player Android (Native, uses player/flake.nix):${NC}
  player android build Build Android APK (release)
  player android run   Build and run on connected Android device
  player android shell Open nix develop shell in player directory

${YELLOW}Player Development:${NC}
  Access: http://localhost:4000/player
  - FlutterWatcher auto-builds on file changes
  - build_runner watch handles code generation

${YELLOW}Metadata Relay:${NC}
  relay deploy         Build, push :dev image, and redeploy to k8s
  relay build          Build :dev Docker image only
  relay push           Push :dev image to ghcr.io
  relay restart        Restart deployment (pull latest image)

${YELLOW}Docker Compose Commands:${NC}
  exec <service> <cmd> Execute command in running service
  run <service> <cmd>  Run one-off command in new container
  build [--no-cache]   Build or rebuild services
  pull                 Pull service images

${YELLOW}Examples:${NC}
  ./dev up -d                    # Start services in background
  ./dev logs -f                  # Follow logs
  ./dev shell                    # Open interactive shell
  ./dev mix test                 # Run tests
  ./dev feature-test             # Run Wallaby browser tests
  ./dev mix ecto.migrate         # Run migrations
  ./dev exec app mix phx.routes  # Show Phoenix routes
  ./dev user list                # List all users
  ./dev user add me@example.com myuser --password=secret123 --role=admin
  ./dev user reset-password admin --password=newpassword
  ./dev player logs              # Follow build_runner logs
  ./dev player build             # Build Flutter web assets

Any other command will be forwarded directly to docker compose.

EOF
    exit 0
fi

# Check if the app container is running
is_container_running() {
    docker compose ps --status=running --format '{{.Service}}' 2>/dev/null | grep -q "^${SERVICE_NAME}$"
}

# Helper function to run commands - uses exec if container is running, otherwise run
run_in_container() {
    if is_container_running; then
        # Use exec for faster execution when container is already running
        # Pass --user to run as the same UID/GID as the host user
        docker compose exec --user "$LOCAL_UID:$LOCAL_GID" "$SERVICE_NAME" "$@"
    else
        # Use run for ephemeral containers when nothing is running
        # The entrypoint will handle user switching via LOCAL_UID/LOCAL_GID env vars
        docker compose run --rm "$SERVICE_NAME" "$@"
    fi
}

# Get the app service image name
# Returns the image name from compose config, or builds it if not available
get_app_image() {
    local image_name
    # Get image name from compose config (now explicitly defined as mydia-app:latest)
    image_name=$(docker compose config --format json 2>/dev/null | jq -r '.services.app.image // empty')

    if [ -z "$image_name" ]; then
        # Fallback for older docker compose versions
        image_name="mydia-app:latest"
    fi

    # Check if image exists locally
    if ! docker image inspect "$image_name" &>/dev/null; then
        echo -e "${YELLOW}App image not found. Building...${NC}" >&2
        docker compose build app >&2
    fi

    echo "$image_name"
}

# Run command in an isolated container (separate volumes from dev)
# Usage: run_isolated <command>
# Example: run_isolated "mix test"
run_isolated() {
    local cmd="$1"
    local app_image
    app_image=$(get_app_image)

    # Use dedicated isolated volumes (separate from dev, but cached between runs)
    # Note: Source must be read-write because Mix touches .ex files during compilation
    docker run --rm \
        -e MIX_ENV=test \
        -e DATABASE_PATH=/tmp/mydia_test.db \
        -e LOCAL_UID="$LOCAL_UID" \
        -e LOCAL_GID="$LOCAL_GID" \
        -e SECRET_KEY_BASE="test_secret_key_base_at_least_64_bytes_long_for_isolated_container" \
        -e MIX_HOME=/app/.mix \
        -e HEX_HOME=/app/.hex \
        -v "$(pwd):/app" \
        -v mydia_isolated_build:/app/_build \
        -v mydia_isolated_deps:/app/deps \
        -v mydia_isolated_mix:/app/.mix \
        -v mydia_isolated_hex:/app/.hex \
        -w /app \
        --entrypoint "" \
        "$app_image" \
        sh -c "mix deps.get && $cmd"
}

# Parse command
COMMAND=$1
shift

case "$COMMAND" in
    # Interactive shell shortcuts
    shell|sh)
        echo -e "${GREEN}Opening interactive shell in $SERVICE_NAME container...${NC}"
        run_in_container sh
        ;;

    bash)
        echo -e "${GREEN}Opening bash shell in $SERVICE_NAME container...${NC}"
        run_in_container bash
        ;;

    iex)
        echo -e "${GREEN}Starting IEx in $SERVICE_NAME container...${NC}"
        # If you pass flags (e.g. -e), forward them to iex.
        # Default is interactive iex -S mix.
        if [ $# -gt 0 ]; then
            run_in_container iex "$@"
        else
            run_in_container iex -S mix
        fi
        ;;

    # Mix command shortcuts
    mix)
        # Run precommit/test in a fully isolated container (no shared volumes)
        if [[ "$1" == "precommit" ]]; then
            echo -e "${GREEN}Running precommit in isolated container...${NC}"
            run_isolated "mix precommit"
        elif [[ "$1" == "test" ]]; then
            echo -e "${GREEN}Running tests in isolated container...${NC}"
            run_isolated "mix ecto.create --quiet && mix ecto.migrate --quiet && mix test ${*:2}"
        else
            run_in_container mix "$@"
        fi
        ;;

    # Common development shortcuts
    test)
        echo -e "${GREEN}Running tests in isolated container...${NC}"
        run_isolated "mix ecto.create --quiet && mix ecto.migrate --quiet && mix test $*"
        ;;

    feature-test)
        echo -e "${GREEN}Running feature tests (Wallaby browser tests)...${NC}"
        docker compose run --rm -e MIX_ENV=test -e LOCAL_UID="$LOCAL_UID" -e LOCAL_GID="$LOCAL_GID" "$SERVICE_NAME" ./scripts/run-feature-tests.sh "$@"
        ;;

    format)
        echo -e "${GREEN}Formatting code...${NC}"
        run_in_container mix format
        ;;

    deps.get)
        echo -e "${GREEN}Installing dependencies...${NC}"
        run_in_container mix deps.get
        ;;

    ecto.migrate)
        echo -e "${GREEN}Running migrations...${NC}"
        run_in_container mix ecto.migrate
        ;;

    ecto.reset)
        echo -e "${GREEN}Resetting database...${NC}"
        run_in_container mix ecto.reset
        ;;

    phx.server)
        echo -e "${GREEN}Starting Phoenix server...${NC}"
        run_in_container mix phx.server
        ;;

    # User management
    user)
        if [ $# -eq 0 ]; then
            echo -e "${RED}Error: user command requires a subcommand${NC}"
            echo "Usage: ./dev user <list|add|delete|reset-password> [args...]"
            exit 1
        fi
        run_in_container mix mydia.user "$@"
        ;;

    # Flutter commands (runs in app container)
    flutter)
        echo -e "${GREEN}Running flutter command in app container...${NC}"
        run_in_container sh -c "cd player && flutter $*"
        ;;

    player)
        case "$1" in
            logs)
                echo -e "${GREEN}Following build_runner logs from app container...${NC}"
                docker compose exec "$SERVICE_NAME" tail -f /tmp/build_runner.log
                ;;
            build)
                echo -e "${GREEN}Building player web assets...${NC}"
                run_in_container sh -c "cd player && flutter build web --release --base-href /player/ --tree-shake-icons"
                echo -e "${GREEN}Player web assets built successfully!${NC}"
                echo -e "${GREEN}Copying build output to priv/static/player...${NC}"
                run_in_container sh -c "rm -rf priv/static/player && cp -r player/build/web priv/static/player"
                # Copy manifest.json if it exists (Flutter doesn't auto-copy it)
                run_in_container sh -c "[ -f player/web/manifest.json ] && cp player/web/manifest.json priv/static/player/"
                echo -e "${GREEN}Build deployed successfully!${NC}"
                ;;
            setup)
                echo -e "${GREEN}Setting up player project (pub get + build_runner)...${NC}"
                run_in_container sh -c "cd player && flutter pub get"
                run_in_container sh -c "cd player && flutter pub run build_runner build --delete-conflicting-outputs"
                echo -e "${GREEN}Player project setup complete!${NC}"
                ;;
            shell)
                echo -e "${GREEN}Opening shell in player directory (app container)...${NC}"
                run_in_container sh -c "cd player && exec bash"
                ;;
            restart)
                echo -e "${GREEN}Restarting app container (includes build_runner)...${NC}"
                docker compose restart "$SERVICE_NAME"
                echo -e "${GREEN}App container restarted. Follow build_runner logs with: ./dev player logs${NC}"
                ;;
            e2e)
                echo -e "${GREEN}Running player E2E integration tests...${NC}"
                echo ""
                echo "This will:"
                echo "  1. Build and start metadata-relay"
                echo "  2. Build and start Mydia (E2E mode with test admin user)"
                echo "  3. Start Selenium Chrome for browser automation"
                echo "  4. Build Flutter web app and run integration tests"
                echo ""
                echo "Test flow: claim code → Noise handshake → device registration"
                echo ""
                echo "Tip: Run './dev player e2e-build' first to pre-cache Docker layers"
                echo ""
                # Build and run E2E tests
                DOCKER_BUILDKIT=1 docker compose -f compose.player-e2e.yml build
                docker compose -f compose.player-e2e.yml up --abort-on-container-exit --exit-code-from test
                exit_code=$?
                # Clean up
                docker compose -f compose.player-e2e.yml down -v
                exit $exit_code
                ;;
            e2e-build)
                echo -e "${GREEN}Pre-building player E2E images (without running tests)...${NC}"
                echo ""
                echo "This pre-builds all E2E Docker images to cache dependencies."
                echo "Subsequent './dev player e2e' runs will be faster."
                echo ""
                DOCKER_BUILDKIT=1 docker compose -f compose.player-e2e.yml build
                echo ""
                echo -e "${GREEN}E2E images pre-built successfully!${NC}"
                echo "Now run './dev player e2e' to execute the tests."
                ;;
            android)
                # Android builds use the player's flake.nix (native, not in Docker)
                if ! command -v nix &> /dev/null; then
                    echo -e "${RED}Error: nix is not installed${NC}"
                    echo "Android builds require Nix. Install from: https://nixos.org/download.html"
                    exit 1
                fi
                
                case "$2" in
                    build)
                        echo -e "${GREEN}Building Android APK using player/flake.nix...${NC}"
                        echo ""
                        nix develop ./player --command bash -c "cd player && flutter pub get && flutter build apk --release"
                        if [ $? -eq 0 ]; then
                            echo ""
                            echo -e "${GREEN}APK built successfully!${NC}"
                            echo "Output: player/build/app/outputs/flutter-apk/app-release.apk"
                        fi
                        ;;
                    run)
                        echo -e "${GREEN}Building and running on Android device...${NC}"
                        echo ""
                        nix develop ./player --command bash -c "cd player && flutter pub get && flutter run"
                        ;;
                    shell)
                        echo -e "${GREEN}Opening nix develop shell in player directory...${NC}"
                        echo ""
                        cd player && nix develop
                        ;;
                    *)
                        echo -e "${RED}Error: Unknown android command: $2${NC}"
                        echo "Usage: ./dev player android <build|run|shell>"
                        exit 1
                        ;;
                esac
                ;;
            *)
                echo -e "${RED}Error: Unknown player command: $1${NC}"
                echo "Usage: ./dev player <logs|build|setup|shell|restart|e2e|e2e-build|android>"
                exit 1
                ;;
        esac
        ;;

    # Metadata relay deployment
    relay)
        RELAY_IMAGE="ghcr.io/getmydia/mydia/metadata-relay:dev"
        RELAY_NAMESPACE="metadata-relay"
        RELAY_DEPLOYMENT="metadata-relay"

        case "$1" in
            build)
                echo -e "${GREEN}Building metadata-relay:dev Docker image...${NC}"
                docker build -f metadata-relay/Dockerfile -t "$RELAY_IMAGE" .
                echo -e "${GREEN}Build complete!${NC}"
                ;;
            push)
                echo -e "${GREEN}Pushing metadata-relay:dev to ghcr.io...${NC}"
                docker push "$RELAY_IMAGE"
                echo -e "${GREEN}Push complete!${NC}"
                ;;
            restart)
                echo -e "${GREEN}Restarting metadata-relay deployment...${NC}"
                kubectl rollout restart deployment/"$RELAY_DEPLOYMENT" -n "$RELAY_NAMESPACE"
                echo -e "${YELLOW}Waiting for rollout to complete...${NC}"
                kubectl rollout status deployment/"$RELAY_DEPLOYMENT" -n "$RELAY_NAMESPACE" --timeout=120s
                echo -e "${GREEN}Deployment restarted successfully!${NC}"
                ;;
            deploy)
                echo -e "${GREEN}Building, pushing, and deploying metadata-relay:dev...${NC}"
                echo ""
                
                # Build
                echo -e "${YELLOW}[1/3] Building Docker image...${NC}"
                docker build -f metadata-relay/Dockerfile -t "$RELAY_IMAGE" .
                if [ $? -ne 0 ]; then
                    echo -e "${RED}Build failed!${NC}"
                    exit 1
                fi
                echo -e "${GREEN}Build complete!${NC}"
                echo ""
                
                # Push
                echo -e "${YELLOW}[2/3] Pushing to ghcr.io...${NC}"
                docker push "$RELAY_IMAGE"
                if [ $? -ne 0 ]; then
                    echo -e "${RED}Push failed!${NC}"
                    exit 1
                fi
                PUSHED_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' "$RELAY_IMAGE" 2>/dev/null | cut -d'@' -f2)
                echo -e "${GREEN}Push complete!${NC}"
                echo ""
                
                # Deploy
                echo -e "${YELLOW}[3/3] Restarting deployment...${NC}"
                kubectl rollout restart deployment/"$RELAY_DEPLOYMENT" -n "$RELAY_NAMESPACE"
                kubectl rollout status deployment/"$RELAY_DEPLOYMENT" -n "$RELAY_NAMESPACE" --timeout=120s
                if [ $? -ne 0 ]; then
                    echo -e "${RED}Deployment failed!${NC}"
                    exit 1
                fi
                
                # Verify digest
                echo ""
                echo -e "${YELLOW}Verifying deployment...${NC}"
                RUNNING_DIGEST=$(kubectl get pod -n "$RELAY_NAMESPACE" -l app.kubernetes.io/name=metadata-relay -o jsonpath='{.items[0].status.containerStatuses[0].imageID}' 2>/dev/null | cut -d'@' -f2)
                if [ -n "$PUSHED_DIGEST" ] && [ -n "$RUNNING_DIGEST" ]; then
                    if [ "$PUSHED_DIGEST" = "$RUNNING_DIGEST" ]; then
                        echo -e "${GREEN}Image digests match!${NC}"
                    else
                        echo -e "${YELLOW}Warning: Digests don't match (may need time to pull)${NC}"
                        echo "  Pushed:  $PUSHED_DIGEST"
                        echo "  Running: $RUNNING_DIGEST"
                    fi
                fi
                
                echo ""
                echo -e "${GREEN}Deployment complete!${NC}"
                echo "  Image: $RELAY_IMAGE"
                echo "  Digest: $PUSHED_DIGEST"
                ;;
            *)
                echo -e "${RED}Error: Unknown relay command: $1${NC}"
                echo "Usage: ./dev relay <deploy|build|push|restart>"
                exit 1
                ;;
        esac
        ;;

    # Forward everything else to docker compose
    *)
        docker compose "$COMMAND" "$@"
        ;;
esac
