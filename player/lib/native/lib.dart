// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `BlobTicket`, `FlutterBlobDownloadProgress`, `FlutterHlsStreamEvent`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<P2pHost>>
abstract class P2PHost implements RustOpaqueInterface {
  /// Dial a peer using their EndpointAddr JSON.
  Future<void> dial({required String endpointAddrJson});

  /// Download a file using a blob ticket over P2P.
  ///
  /// This uses the HLS streaming infrastructure to download the file in chunks,
  /// providing progress updates to the sink as JSON strings. The file is saved
  /// to the specified output path.
  ///
  /// Progress messages are JSON: {"type": "started|progress|completed|failed", ...}
  /// - started: {"type": "started", "total_size": <bytes>}
  /// - progress: {"type": "progress", "downloaded": <bytes>, "total": <bytes>}
  /// - completed: {"type": "completed", "file_path": "<path>"}
  /// - failed: {"type": "failed", "error": "<message>"}
  ///
  /// The ticket JSON should contain: hash, file_size, filename, file_path
  Stream<String> downloadBlob(
      {required String peer,
      required String ticketJson,
      required String outputPath,
      String? authToken});

  /// Start streaming events to Flutter.
  Stream<String> eventStream();

  /// Get network statistics.
  FlutterNetworkStats getNetworkStats();

  /// Get this node's EndpointAddr as JSON for sharing.
  String getNodeAddr();

  /// Initialize a new P2P host with optional custom relay URL.
  static (P2PHost, String) init({String? relayUrl}) =>
      RustLib.instance.api.crateP2PHostInit(relayUrl: relayUrl);

  /// Request a blob download ticket from the server for a transcode job.
  ///
  /// This sends a BlobDownload request to the server which returns a ticket
  /// containing the file hash, size, and path. The ticket can then be used
  /// with download_blob() to download the actual file.
  Future<FlutterBlobDownloadResponse> requestBlobDownload(
      {required String peer, required FlutterBlobDownloadRequest req});

  /// Send a GraphQL request to a specific peer.
  Future<FlutterGraphQLResponse> sendGraphqlRequest(
      {required String peer, required FlutterGraphQLRequest req});

  /// Send an HLS request to a specific peer and collect the complete response.
  ///
  /// This is a non-streaming version that collects all chunks into a single buffer.
  /// For large files, consider using the local proxy service instead.
  Future<FlutterHlsResponse> sendHlsRequest(
      {required String peer, required FlutterHlsRequest req});

  /// Send a pairing request to a specific peer.
  Future<FlutterPairingResponse> sendPairingRequest(
      {required String peer, required FlutterPairingRequest req});
}

/// Request to download a file as a blob over P2P
class FlutterBlobDownloadRequest {
  final String jobId;
  final String? authToken;

  const FlutterBlobDownloadRequest({
    required this.jobId,
    this.authToken,
  });

  @override
  int get hashCode => jobId.hashCode ^ authToken.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterBlobDownloadRequest &&
          runtimeType == other.runtimeType &&
          jobId == other.jobId &&
          authToken == other.authToken;
}

/// Response with blob ticket for downloading
class FlutterBlobDownloadResponse {
  final bool success;

  /// The blob ticket as a JSON string containing hash, file_size, filename, file_path
  final String? ticket;

  /// Original filename for the downloaded file
  final String? filename;

  /// File size in bytes
  final BigInt? fileSize;

  /// Error message if failed
  final String? error;

  const FlutterBlobDownloadResponse({
    required this.success,
    this.ticket,
    this.filename,
    this.fileSize,
    this.error,
  });

  @override
  int get hashCode =>
      success.hashCode ^
      ticket.hashCode ^
      filename.hashCode ^
      fileSize.hashCode ^
      error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterBlobDownloadResponse &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          ticket == other.ticket &&
          filename == other.filename &&
          fileSize == other.fileSize &&
          error == other.error;
}

/// Connection type for a peer (relay vs direct) for display in Flutter UI
enum FlutterConnectionType {
  /// Direct peer-to-peer connection
  direct,

  /// Connection via relay server
  relay,

  /// Using both relay and direct paths
  mixed,

  /// No active connection
  none,
  ;
}

/// GraphQL request to send over P2P
class FlutterGraphQLRequest {
  final String query;
  final String? variables;
  final String? operationName;
  final String? authToken;

  const FlutterGraphQLRequest({
    required this.query,
    this.variables,
    this.operationName,
    this.authToken,
  });

  @override
  int get hashCode =>
      query.hashCode ^
      variables.hashCode ^
      operationName.hashCode ^
      authToken.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterGraphQLRequest &&
          runtimeType == other.runtimeType &&
          query == other.query &&
          variables == other.variables &&
          operationName == other.operationName &&
          authToken == other.authToken;
}

/// GraphQL response received over P2P
class FlutterGraphQLResponse {
  final String? data;
  final String? errors;

  const FlutterGraphQLResponse({
    this.data,
    this.errors,
  });

  @override
  int get hashCode => data.hashCode ^ errors.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterGraphQLResponse &&
          runtimeType == other.runtimeType &&
          data == other.data &&
          errors == other.errors;
}

/// HLS request to send over P2P
class FlutterHlsRequest {
  final String sessionId;
  final String path;
  final BigInt? rangeStart;
  final BigInt? rangeEnd;
  final String? authToken;

  const FlutterHlsRequest({
    required this.sessionId,
    required this.path,
    this.rangeStart,
    this.rangeEnd,
    this.authToken,
  });

  @override
  int get hashCode =>
      sessionId.hashCode ^
      path.hashCode ^
      rangeStart.hashCode ^
      rangeEnd.hashCode ^
      authToken.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterHlsRequest &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          path == other.path &&
          rangeStart == other.rangeStart &&
          rangeEnd == other.rangeEnd &&
          authToken == other.authToken;
}

/// HLS stream complete response (non-streaming version)
class FlutterHlsResponse {
  final FlutterHlsResponseHeader header;
  final Uint8List data;

  const FlutterHlsResponse({
    required this.header,
    required this.data,
  });

  @override
  int get hashCode => header.hashCode ^ data.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterHlsResponse &&
          runtimeType == other.runtimeType &&
          header == other.header &&
          data == other.data;
}

/// HLS response header received over P2P
class FlutterHlsResponseHeader {
  final int status;
  final String contentType;
  final BigInt contentLength;
  final String? contentRange;
  final String? cacheControl;

  const FlutterHlsResponseHeader({
    required this.status,
    required this.contentType,
    required this.contentLength,
    this.contentRange,
    this.cacheControl,
  });

  @override
  int get hashCode =>
      status.hashCode ^
      contentType.hashCode ^
      contentLength.hashCode ^
      contentRange.hashCode ^
      cacheControl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterHlsResponseHeader &&
          runtimeType == other.runtimeType &&
          status == other.status &&
          contentType == other.contentType &&
          contentLength == other.contentLength &&
          contentRange == other.contentRange &&
          cacheControl == other.cacheControl;
}

/// Network statistics for display in the UI
class FlutterNetworkStats {
  final BigInt connectedPeers;
  final bool relayConnected;

  /// The relay URL currently in use (extracted from endpoint address)
  final String? relayUrl;

  /// Connection type for the connected peer (relay vs direct)
  final FlutterConnectionType peerConnectionType;

  const FlutterNetworkStats({
    required this.connectedPeers,
    required this.relayConnected,
    this.relayUrl,
    required this.peerConnectionType,
  });

  @override
  int get hashCode =>
      connectedPeers.hashCode ^
      relayConnected.hashCode ^
      relayUrl.hashCode ^
      peerConnectionType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterNetworkStats &&
          runtimeType == other.runtimeType &&
          connectedPeers == other.connectedPeers &&
          relayConnected == other.relayConnected &&
          relayUrl == other.relayUrl &&
          peerConnectionType == other.peerConnectionType;
}

class FlutterPairingRequest {
  final String claimCode;
  final String deviceName;
  final String deviceType;
  final String? deviceOs;

  const FlutterPairingRequest({
    required this.claimCode,
    required this.deviceName,
    required this.deviceType,
    this.deviceOs,
  });

  @override
  int get hashCode =>
      claimCode.hashCode ^
      deviceName.hashCode ^
      deviceType.hashCode ^
      deviceOs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterPairingRequest &&
          runtimeType == other.runtimeType &&
          claimCode == other.claimCode &&
          deviceName == other.deviceName &&
          deviceType == other.deviceType &&
          deviceOs == other.deviceOs;
}

class FlutterPairingResponse {
  final bool success;
  final String? mediaToken;
  final String? accessToken;
  final String? deviceToken;
  final String? error;
  final List<String> directUrls;

  const FlutterPairingResponse({
    required this.success,
    this.mediaToken,
    this.accessToken,
    this.deviceToken,
    this.error,
    required this.directUrls,
  });

  @override
  int get hashCode =>
      success.hashCode ^
      mediaToken.hashCode ^
      accessToken.hashCode ^
      deviceToken.hashCode ^
      error.hashCode ^
      directUrls.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FlutterPairingResponse &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          mediaToken == other.mediaToken &&
          accessToken == other.accessToken &&
          deviceToken == other.deviceToken &&
          error == other.error &&
          directUrls == other.directUrls;
}
